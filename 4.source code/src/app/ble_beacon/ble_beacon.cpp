/**
 * @file ble_beacon.cpp
 * @author Mingo
 * @brief BLE Beacon app implementation for Mooncake
 * @version 0.1
 * @date 2025-08-05
 * @copyright Copyright (c) 2025
 */

#include "ble_beacon.h"

/*
  These are audio devices: wireless headphones / earbuds
  It seems these need a shorter range between ESP & iDevice
*/
const uint8_t IOS_DEVICES[][31] = {
  // Airpods
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x02, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Airpods Pro
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0e, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Airpods Max
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0a, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Airpods Gen 2
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0f, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Airpods Gen 3
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x13, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Airpods Pro Gen 2
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x14, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Power Beats
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x03, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Power Beats Pro
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0b, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Solo Pro
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0c, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Studio Buds
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x11, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Flex
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x10, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats X
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x05, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Solo 3
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x06, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Studio 3
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x09, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Studio Pro
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x17, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Fit Pro
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x12, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  // Beats Studio Buds Plus
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x16, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

/*
  These are more general home devices
  It seems these can work over long distances, especially AppleTV Setup
*/
const uint8_t SHORT_DEVICES[][23] = {
  // AppleTV Setup
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x01, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV Pair
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x06, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV New User
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x20, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV AppleID Setup
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x2b, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV Wireless Audio Sync
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0xc0, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV Homekit Setup
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x0d, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV Keyboard Setup
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x13, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // AppleTV Connecting to Network
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x27, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // Homepod Setup
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x0b, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // Setup New Phone
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x09, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // Transfer Number
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x02, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // TV Color Balance
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x1e, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  // Vision Pro
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x24, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
};

namespace MOONCAKE::APPS
{
    // 构造函数实现
    BleBeacon::BleBeacon(DEVICES* device)
        : AppAbility()
        , _device(device)
        , pAdvertising(nullptr)
        , pServer(nullptr)
        , delayMilliseconds(1000)
        , isInitialized(false)
        , currentLine(0)
    {
        setAppInfo().name = "BLE Beacon";
    }

    // Auxiliary method: Display text on background image (transparent background)
    void BleBeacon::displayTextOnBackground(const char* text, bool newLine)
    {
        if (!_device) return;
        
        // Set the text style - do not use a black background, let the text appear directly on the image background
        _device->Lcd.setTextColor(TFT_GREEN);  // Only set the foreground color, the background is transparent
        _device->Lcd.setFont(&fonts::efontCN_16);
        
        // Calculate display position
        int lineHeight = 20;  // Font height + spacing
        int startY = 30;      // Starting Y position, avoid the main content of the picture
        int startX = 15;      // Starting X position, leaving margin on the left
        
        if (newLine) {
            currentLine++;
            _device->Lcd.setCursor(startX, startY + (currentLine - 1) * lineHeight);
        }
        
        _device->Lcd.print(text);
    }

    // Clean up the display area - avoid flickering caused by full screen refresh
    void BleBeacon::clearDisplayArea()
    {
        if (!_device) return;
        
        currentLine = 0;
        
        // Avoid full screen refresh and only redisplay the background image
    _device->Lcd.pushImage(0, 0, ble_beacon_bg_png.width, ble_beacon_bg_png.height, (uint16_t*)ble_beacon_bg_png.data);

        // Optional: If you need to clear a specific text area instead of refreshing the entire screen
        // int textAreaY = 30;
        // int textAreaHeight = 200;  // Adjust according to actual needs
        // _device->Lcd.fillRect(0, textAreaY, _device->Lcd.width(), textAreaHeight, TFT_BLACK);
        // _device->Lcd.pushImage(0, 0, spam_apple.width, spam_apple.height, (uint16_t*)spam_apple.data);
    }

    void BleBeacon::onOpen()
    {
        if (isInitialized) {
            return;
        }

        if (!_device) {
            return;
        }

        // Ensure that previous BLE resources are cleaned up
        BLEDevice::deinit(false);
        delay(200);

        // Show background image for the first time - clear the screen only once
        _device->Lcd.fillScreen(TFT_BLACK);
        _device->Lcd.pushImage(0, 0, ble_beacon_bg_png.width, ble_beacon_bg_png.height, (uint16_t*)ble_beacon_bg_png.data);
        currentLine = 0;

        try {
            BLEDevice::init("AirPods 69");
            // Increase the BLE Power to 21dBm (MAX)
            esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, MAX_TX_POWER);
            
            // show short init messages
            displayTextOnBackground("Starting...");
            delay(300);
            
            // Create the BLE Server
            pServer = BLEDevice::createServer();
            if (pServer == nullptr) {
                displayTextOnBackground("Server failed");
                return;
            }

            displayTextOnBackground("Server OK");
            delay(200);
            
            pAdvertising = pServer->getAdvertising();
            if (pAdvertising == nullptr) {
                displayTextOnBackground("Adv failed");
                return;
            }

            displayTextOnBackground("Adv OK");
            delay(200);

            // seems we need to init it with an address in setup() step.
            esp_bd_addr_t null_addr = {0xFE, 0xED, 0xC0, 0xFF, 0xEE, 0x69};
            pAdvertising->setDeviceAddress(null_addr, BLE_ADDR_TYPE_RANDOM);
            
            isInitialized = true;

            // final short status
            displayTextOnBackground("Addr set");
            displayTextOnBackground("Running");
            displayTextOnBackground("Simulating...");
            displayTextOnBackground("Press B to exit");
            
        } catch (const std::exception& e) {
            displayTextOnBackground("Init error");
            isInitialized = false;
        }
    }

    void BleBeacon::onRunning()
    {
        if (!isInitialized || !pAdvertising || !pServer || !_device) {
            return;
        }

        try {
            // First generate fake random MAC
            esp_bd_addr_t dummy_addr = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
            for (int i = 0; i < 6; i++){
                dummy_addr[i] = random(256);
                if (i == 0){
                    dummy_addr[i] |= 0xF0;
                }
            }

            BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();

            // Randomly pick data from one of the devices
            int device_choice = random(2);
            if (device_choice == 0){
                int index = random(17);
                oAdvertisementData.addData(std::string((char*)IOS_DEVICES[index], 31));
            } else {
                int index = random(13);
                oAdvertisementData.addData(std::string((char*)SHORT_DEVICES[index], 23));
            }

            int adv_type_choice = random(3);
            if (adv_type_choice == 0){
                pAdvertising->setAdvertisementType(ADV_TYPE_IND);
            } else if (adv_type_choice == 1){
                pAdvertising->setAdvertisementType(ADV_TYPE_SCAN_IND);
            } else {
                pAdvertising->setAdvertisementType(ADV_TYPE_NONCONN_IND);
            }

            // Set the device address, advertisement data
            pAdvertising->setDeviceAddress(dummy_addr, BLE_ADDR_TYPE_RANDOM);
            pAdvertising->setAdvertisementData(oAdvertisementData);

            // Start advertising
            pAdvertising->start();
            delay(delayMilliseconds);
            pAdvertising->stop();

            // Random signal strength
            int rand_val = random(100);
            if (rand_val < 70) {
                esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, MAX_TX_POWER);
            } else if (rand_val < 85) {
                esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, (esp_power_level_t)(MAX_TX_POWER - 1));
            } else if (rand_val < 95) {
                esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, (esp_power_level_t)(MAX_TX_POWER - 2));
            } else if (rand_val < 99) {
                esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, (esp_power_level_t)(MAX_TX_POWER - 3));
            } else {
                esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, (esp_power_level_t)(MAX_TX_POWER - 4));
            }

            // Display real-time status - reduce refresh frequency to avoid screen flickering
            static uint32_t lastUpdate = 0;
            static uint32_t packetCount = 0;
            static int lastDeviceChoice = -1;
            static int lastRandVal = -1;
            
            if (millis() - lastUpdate > 3000) {  // Increase the update time to 3 seconds to reduce flickering
                lastUpdate = millis();
                packetCount++;
                
                // Update the display only when the data actually changes
                if (device_choice != lastDeviceChoice || rand_val != lastRandVal) {
                    lastDeviceChoice = device_choice;
                    lastRandVal = rand_val;
                    
                    // Use partial refresh instead of full screen refresh
                    // Clean the text area first
                    int textStartY = 30;
                    int textHeight = 180;  // Adjust according to the actual number of text lines
                    
                    // Redraw the text area of ​​the background image
                    _device->Lcd.pushImage(0, textStartY, ble_beacon_bg_png.width, textHeight, 
                                           (uint16_t*)ble_beacon_bg_png.data + (textStartY * ble_beacon_bg_png.width));

                    currentLine = 0; // Reset line counter for new text display
                    
            // show concise running info
            displayTextOnBackground("Beacon");
            displayTextOnBackground("Active");
            displayTextOnBackground("Simulating...");
            displayTextOnBackground(""); // spacer

            // dynamic info
            char buffer[64];
            sprintf(buffer, "Packets: %d", packetCount);
            displayTextOnBackground(buffer);

            sprintf(buffer, "Type: %s", device_choice == 0 ? "Audio" : "Home");
            displayTextOnBackground(buffer);

            sprintf(buffer, "Power: %s", rand_val < 70 ? "Max" : "Rand");
            displayTextOnBackground(buffer);

            displayTextOnBackground(""); // spacer
            displayTextOnBackground("Press B to exit");
                }
            }
        } catch (const std::exception& e) {
        displayTextOnBackground("Run error");
        }
    }

    void BleBeacon::onClose()
    {
        if (!isInitialized) return;

        // Safe shutdown: stop advertising and server, reset TX power, deinit BLE
        if (pAdvertising) {
            try { pAdvertising->stop(); } catch (...) {}
            pAdvertising = nullptr;
        }

        if (pServer) {
            try { pServer->getAdvertising()->stop(); } catch (...) {}
            pServer = nullptr;
        }

        esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, ESP_PWR_LVL_N0);
        esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_SCAN, ESP_PWR_LVL_N0);
        esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_DEFAULT, ESP_PWR_LVL_N0);

        isInitialized = false;

        try { BLEDevice::deinit(false); } catch (...) {}
        _device->Lcd.fillScreen(TFT_BLACK);
    }
}